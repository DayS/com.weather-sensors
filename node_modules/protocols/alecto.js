"use strict";

/*
Copyright (c) 2017-2020 Ram√≥n Baas

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/*
  Alecto Protocol
*/

const utils = require('utils');

class AlectoV1 extends utils.WeatherSignal {

  constructor() {
    super({
      id: 'alectov1',
      name: 'Alecto v1',
      signal: 'AlectoV1',
      hint: {
        en: 'Support Alecto v1 sensors & Labs BL999',
        nl: 'Ondersteunt Alecto v1 sensoren & Labs BL999'
      }
    })
  }

  parse(payLoad) {
    let result;
    let data = Array.prototype.slice.call(payLoad, 0);
    let dataStr = data.join('');
    let id1 = dataStr.slice(0, 4);
    let id2 = dataStr.slice(28, 36);
    if (id1 === '1001' && id2 === '11001100') {
      // We've found a WS-1050 outdoor sensor
      result = this.decodeAlectoWS(dataStr, '1050');
    }
    if (result === undefined || !this.validate(result)) {
      let decVal = '';
      for (let i = 0; i < data.length; i += 4) {
        decVal += (data.slice(i, i + 4)).reverse().join('');
      }
      let type = this.determineTypeAlectoV1(data);
      if (type !== undefined) {
        let crc = this.calcSimpleCRC(decVal, type);
        let check = Number(utils.bin2dec(decVal.slice(32, 36)));
        if (crc === check) {
          result = this.decodeAlectoV1(data, type);
        } else {
          result = new Error('CRC error for Alecto v1 data (' + crc + ' vs ' + check + ')');
        }
      } else {
        result = new Error('Unknown sensor type')
      }
    }
    if (result instanceof Error || !this.validate(result)) {
      let crc = this.calcSimpleSum(data);
      let check = Number(utils.bin2dec(data.slice(32, 36).reverse().join('')));
      if (crc === check) {
         result = this.decodeLabs(data);
      }
    }
    if (result instanceof Error || !this.validate(result)) {
      if (id1 === '0101') {
        result = this.decodeAlectoWS(dataStr, '1xxx');
      }
    }

    return result;
  }

  // Calculate simple Alecto v1 CRC
  // See http://www.tfd.hu/tfdhu/files/wsprotocol/auriol_protocol_v20.pdf
  calcSimpleCRC(data, type) {
    let rain = type === 'R';
    let crc = (rain ? 0x7 : 0xf);
    for (let i = 0; i < 8; i++) {
      let val = Number(utils.bin2dec(data.slice(4 * i, 4 * (i + 1))));
      if (rain) {
        crc += val;
      } else {
        crc -= val;
      }
    }
    return (crc & 0xf);
  }

  // Calculate checksum for Labs
	calcSimpleSum(data) {
		let sum = 0;
		for (let i = 0; i < (data.length >> 2) - 1; i++) {
			sum += Number(utils.bin2dec(data.slice(i * 4, (i + 1) * 4).reverse().join('')));
		}
		return sum & 0xf;
	}

  // Determine what kind of data we receive
  determineTypeAlectoV1(data) {
    let datastr = data.join('');
    let type = 'TH';
    if (datastr.slice(9, 11) === '11') {
      type = undefined;
      if (datastr.slice(12, 16) === '1100') {
        type = 'R';
      } else if (datastr.slice(12, 15) === '111' || datastr.slice(12, 24) === '100000000000') {
        type = 'W';
      }
    }
    return type;
  }

  // Decode the received v1 data
  decodeAlectoV1(data, type) {
    let id = utils.bin2dec(data.slice(0, 8).reverse().join(''));
    let result = {
      id: id,
      data: {}
    }
    // Decode the data based on the type
    if (type === 'TH') {
      let temperature = data.slice(12, 24).reverse().join('');
      if (temperature[0] === '1') {
        // make it 32 bit, convert 2's complement
        temperature = ~~parseInt('11111111111111111111' + temperature, 2);
      } else {
        temperature = utils.bin2dec(temperature);
      }
      let humidity = utils.bin2dec(data.slice(28, 32).reverse().join(''))
        + utils.bin2dec(data.slice(24, 28).reverse().join(''))
      result.data.temperature = Number((temperature / 10).toFixed(1));
      result.data.humidity = Number(humidity);
      result.channel = Number(utils.bin2dec(data.slice(4, 6).reverse().join(''))) + 1;
    } else if (type === 'R') {
      let rain = utils.bin2dec(data.slice(16, 32).reverse().join(''));
      result.data.raintotal = rain * 0.25;
    } else if (type === 'W') {
      let val = utils.bin2dec(data.slice(24, 32).reverse().join('')) * 0.72; // km/h
      if (data.slice(12, 15).every(x => x === 1)) { // '111'
        result.data.direction = Number(utils.bin2dec(data.slice(15, 24).reverse().join('')));
        result.data.currentspeed = val; // gust
      } else {
        result.data.averagespeed = val;
      }
    }
    result.data.lowbattery = (data[8] === 1);

    return result;
  }

  // WS1050/WS1150/WS1700 specific
  decodeAlectoWS(data, sensorId) {
    let temperature = data.slice(16, 28);
    if (temperature[0] === '1') {
      // make it 32 bit, convert 2's complement
      temperature = ~~parseInt('11111111111111111111' + temperature, 2);
    } else {
      temperature = utils.bin2dec(temperature);
    }
    let humidity = data.slice(28, 36);

    let result = {
      id: utils.bin2dec(data.slice(4, 12)),
      name: 'WS-' + sensorId,
      channel: Number(utils.bin2dec(data.slice(14, 16))) + 1,
      data: {
        temperature: Number((temperature / 10).toFixed(1)),
        humidity:Number(utils.bin2dec(humidity)),
        button: data[13] === '1',
        lowbattery: data[12] === '1'
      }
    };
    if (humidity === '11001100') {
      delete result.data.humidity;
    }

    return result;
  }

  // Decode the Labs protocol
	decodeLabs(data) {
	  let id = utils.bin2dec(data.slice(0, 4).reverse().join('') + data.slice(6, 8).reverse().join(''));

	  let temperature = data.slice(12, 24).reverse().join('');
	  if (temperature[0] === '1') {
	    // make it 32 bit, convert 2's complement
	    temperature = ~~parseInt('11111111111111111111' + temperature, 2);
	  } else {
	    temperature = utils.bin2dec(temperature);
	  }
	  let humidity = 100 - (255 - utils.bin2dec(data.slice(24, 32).reverse().join('')));

		let result = {
	    name: 'BL999',
			id: id,
			pid: 'labs', // override default 'tfa' protocol ID
	    channel: Number(utils.bin2dec(data.slice(4, 6).join(''))),
			data: {
	      temperature: Number((temperature / 10).toFixed(1)),
	      humidity: humidity,
	      lowbattery: data[8] === '1'
	    }
		}

		return result;
	}

}

class AlectoV3 extends utils.WeatherSignal {

  constructor() {
    super({
      id: 'alectov3',
      name: 'Alecto v3',
      signal: 'AlectoV3',
      hint:  {
        en: 'Supports Alecto WS-1100 & WS-1200 and Fine Offset WH2(A)',
        nl: 'Ondersteunt Alecto WS-1100/WS-1200 en Fine Offset WH2(A)'
      }
    })
  }

  // Parse the data according to the Alecto v3 protocol
  parse(payLoad) {
    let result;
    let payload_length = payLoad.length;
    let data = Array.prototype.slice.call(payLoad, 0);
    if (data.length % 4 !== 0) {
      data = data.splice(data.length % 4)
    }
    let decVal = data.join('');
    let len = data.length;
  	let crcVals = [];
  	for (let i = 0; i < (len >> 3) - 1; i++) {
  		crcVals[i] = Number(utils.bin2dec(decVal.slice(8 * i, 8 * (i + 1))));
  	}
  	let crc = this.calcAlectoCRC8(crcVals);
  	let check = Number(utils.bin2dec(decVal.slice(len - 8, len)));
  	if (crc === check) {
  		result = this.decodeAlectoV3(decVal, payload_length);
  	} else {
  		result = new Error('CRC error (' + crc + ' vs ' + check + ')');
  	}
    return result;
  }

  // CRC calculation for Alecto v2 & v3
  // Taken from https://github.com/rinie/RFSniffer/blob/master/ScanDevices.ino
  calcAlectoCRC8(data) {
    let crc = 0;
    let x = 0;
    let len = data.length;
    // Indicated changes are from reference CRC-8 function in OneWire library
    while (len--) {
      let inbyte = data[x++];
      for (let i = 0; i < 8; i++) {
        let mix = (crc ^ inbyte) & 0x80; // changed from & 0x01
        crc = (crc << 1) & 0xff; // changed from right shift
        if (mix) {
          crc ^= 0x31;// changed from 0x8C;
        }
        inbyte = (inbyte << 1) & 0xff; // changed from right shift
      }
    }
    return crc;
  }

  // Decode the received v3 data
  decodeAlectoV3(data, original_length) {
    let id = utils.bin2dec(data.slice(4, 12))
    let type = data.length === 40 ? 'TH' : 'R'
    /*
       There are multiple sensors that use the same protocol and similar encoding, but are
       slightly different:
       - Alecto WS-1100/WS-1200: has no sign bit; temperature value is 40 deg higher; has low battery bit (12)
       - Fine Offset WH2(A): has sign bit (12); has no low battery status
    */
    let result
    let temperature = utils.bin2dec(data.slice(13, 24)) / 10
    let humidity = Number(utils.bin2dec(data.slice(24, 32)))
    let sensor = (type === 'TH' ? 'WS-1100' : 'WS-1200')
    let FineOffset = original_length === 42
    if (type === 'TH') {
      if (humidity === 255) {
        FineOffset = true
        type = 'T'
      } else {
        // Note: not ideal to check the temperature value to see if it is FineOffset or not (bit 14)
        FineOffset = FineOffset || (data[11] === '1' && data[14] === '0')
      }
    }
    if (FineOffset) {
      let sign = (data[12] === '1' ? -1 : 1);
      result = {
        id: id,
        channel: Number(utils.bin2dec(data.slice(5, 8))) + 1,
        name: 'WH2',
        data: { temperature: Number((sign * temperature).toFixed(1)) }
      }
      if (data.slice(9, 12) !== '111' && type !== 'T') {
        delete result.channel
        result.name = 'WH2A'
      }
      if (type === 'TH') {
        result.data.humidity = humidity
      }
    } else {
      // Alecto
      result = {
        id: id,
        channel: Number(utils.bin2dec(data.slice(2, 4))) + 1,
        name: sensor,
        data: { temperature: Number((-40 + temperature).toFixed(1)) }
      }
      if (type === 'TH') {
        result.data.humidity = humidity
      } else { // Rain sensor (WS-1200)
        let rain = utils.bin2dec(data.slice(32, 40)) * 256 + utils.bin2dec(data.slice(24, 32));
        result.data.rainrate = rain * 0.3
      }
      result.data.lowbattery = data[12] === '1'
    }

    return result;
  }

}

module.exports = {
  alectov1: AlectoV1,
  alectov3: AlectoV3
}
